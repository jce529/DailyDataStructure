import java.util.*;

public class Main {
    public static void main(String[] args) {
    Scanner input = new Scanner(System.in);
    
    int n = input.nextInt() + 1;//노드의 개수
    int m = input.nextInt();//간선의 개수
    
    int[][] graph = new int[n][n]; //노드간의 연결을 표시할 2차원 그래프프
    
    for (int i = 0; i < m; i++){
      //간선의 개수만큼 반복
      int x = input.nextInt();
      int y = input.nextInt();
      
      graph[x][y] = 1;
      graph[y][x] = 1;
    }
    //아마 이 문제는 dfs, bfs 둘 다 풀 수 있을 듯?
    
    //bfs풀이이
    Queue<Integer> q = new LinkedList<Integer>();//움직일 노드를 저장할 큐 선언
    boolean[] isVisited = new boolean[n];//해당 노드를 방문했는지 확인하기 위한 배열 선언
    int c = -1;
    
    for (int i = 0; i < n; i++){
      //노드의 숫자만큼 반복
      if(!isVisited[i]){
        c++;
        //만약 해당 노드를 방문하지 않았다면
        q.add(i);//큐에 해당 노드를 넣고
        isVisited[i] = true;//해당 노드를 방문처리
        
        while (!q.isEmpty()){
          //큐가 빌 때까지 반복
          int node = q.poll(); //q에서 노드 빼오기
          
          //연결된 다른 노드가 있는지 확인하기
          for (int j = 0; j < n; j++){
            if(graph[node][j] == 1 && !isVisited[j]){
              q.add(j);//연결된 노드를 큐에 넣고
              isVisited[j] = true;//방문처리
            }
          }
        }
      }
    }
    
    System.out.println(c);
  }
}

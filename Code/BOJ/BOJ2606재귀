import java.util.*;


public class Main {
    public static void main(String[] args) {
    Scanner input = new Scanner(System.in);
    //노드의 개수
    int N = Integer.parseInt(input.nextLine());
    //간선의 개수
    int routeN = Integer.parseInt(input.nextLine());
    //시작 노드와 연결된 개수(자신 제외외)
    int connected = -1;
    
    //간선을 표시할 2차원 배열 선언
    boolean[][] graph = new boolean[N+1][N+1];
    //해당 인덱스의 노드를 방문했는지 확인하는 배열 선언
    boolean[] isVisited = new boolean[N+1];
    
    
    for (int i = 0; i < routeN; i++){//간선의 개수만큼 반복
      String[] strings = input.nextLine().split(" "); //입력 받기
      
      int x = Integer.parseInt(strings[0]);
      int y = Integer.parseInt(strings[1]);
      
      addEdge(graph,x,y);//xy연결 간선 표시
    }
    
    startDFS(graph, isVisited, 1);
    
    for (int i = 0; i < N+1; i++){
      if (isVisited[i] == true) connected++; 
    }
    System.out.println(connected);
  }
  
  static void addEdge(boolean[][] graph, int x, int y){
    graph[x][y] = true;
    graph[y][x] = true;
  }
  
  //연결된 간선을 따라서 호출할 재귀 함수 만들기
  static void startDFS(boolean[][] graph, boolean[] isVisited, int nodeIndex){
    //일단 시작하는 인덱스를 방문처리 할까?
    isVisited[nodeIndex] =  true;
    
    //그리고 앞으로 방문처리할 놈 찾아보자
    //참고로 얘는 스택이 아니라 낮은놈부터 ㄱㄱㄱ
    for (int i = 0; i < graph[nodeIndex].length; i++){
      //해당 노드와 연결되어 있으면서, 방문하지 않은 노드가 있으면
      if (graph[nodeIndex][i] == true && !isVisited[i]){
        //함수 호출
        startDFS(graph, isVisited, i);
      }
    }
  }
}
